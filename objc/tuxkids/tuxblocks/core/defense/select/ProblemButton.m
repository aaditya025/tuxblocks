//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: C:\Users\Thomas\Documents\Eclipse\Tux\tuxblocks\core\src\main\java\tuxkids\tuxblocks\core\defense\select\ProblemButton.java
//
//  Created by Thomas on 7/1/13.
//

#import "java/lang/Math.h"
#import "playn/core/Canvas.h"
#import "playn/core/CanvasImage.h"
#import "playn/core/Font.h"
#import "playn/core/Graphics.h"
#import "playn/core/Image.h"
#import "playn/core/Layer.h"
#import "playn/core/PlayN.h"
#import "playn/core/TextFormat.h"
#import "playn/core/TextLayout.h"
#import "playn/core/util/Clock.h"
#import "tripleplay/util/Colors.h"
#import "tuxkids/tuxblocks/core/Button.h"
#import "tuxkids/tuxblocks/core/Constant.h"
#import "tuxkids/tuxblocks/core/PlayNObject.h"
#import "tuxkids/tuxblocks/core/defense/round/Reward.h"
#import "tuxkids/tuxblocks/core/defense/select/Problem.h"
#import "tuxkids/tuxblocks/core/defense/select/ProblemButton.h"
#import "tuxkids/tuxblocks/core/defense/tower/Tower.h"
#import "tuxkids/tuxblocks/core/defense/tower/TowerType.h"
#import "tuxkids/tuxblocks/core/solve/expression/Equation.h"
#import "tuxkids/tuxblocks/core/solve/expression/Expression.h"
#import "tuxkids/tuxblocks/core/solve/expression/ExpressionWriter.h"

@implementation TBProblemButton

- (TBProblem *)problem_ {
  return problem__;
}
- (void)setProblem_:(TBProblem *)problem_ {
  JreOperatorRetainedAssign(&problem__, self, problem_);
}
@synthesize problem_ = problem__;
@synthesize minHeight = minHeight_;
- (TBProblemButton *)above_ {
  return above__;
}
- (void)setAbove_:(TBProblemButton *)above_ {
  JreOperatorRetainedAssign(&above__, self, above_);
}
@synthesize above_ = above__;
- (TBProblemButton *)below_ {
  return below__;
}
- (void)setBelow_:(TBProblemButton *)below_ {
  JreOperatorRetainedAssign(&below__, self, below_);
}
@synthesize below_ = below__;
@synthesize towerColor = towerColor_;
@synthesize targetAlpha = targetAlpha_;

+ (int)MARGIN {
  return TBProblemButton_MARGIN;
}

- (TBEquation *)equation {
  return [((TBProblem *) NIL_CHK(problem__)) equation];
}

- (void)setEquationWithTBEquation:(TBEquation *)equation {
  [((TBProblem *) NIL_CHK(problem__)) setEquationWithTBEquation:equation];
  [self setImageWithPlaynCoreImage:[TBProblemButton createImageWithTBProblem:problem__ withFloat:[self width] withFloat:minHeight_ withInt:towerColor_]];
  float top = [self top];
  [self setSizeWithFloat:[((id<PlaynCoreImage>) [self image]) width] withFloat:[((id<PlaynCoreImage>) [self image]) height]];
  [self setTopWithFloat:top];
}

- (void)setAboveWithTBProblemButton:(TBProblemButton *)above {
  self.above_ = above;
}

- (void)setBelowWithTBProblemButton:(TBProblemButton *)below {
  self.below_ = below;
}

- (TBProblemButton *)above {
  return above__;
}

- (TBProblemButton *)below {
  return below__;
}

- (TBProblem *)problem {
  return problem__;
}

- (id)initWithTBProblem:(TBProblem *)problem
              withFloat:(float)width
              withFloat:(float)minHeight
                withInt:(int)towerColor {
  if ((self = [super initWithPlaynCoreImage:[TBProblemButton createImageWithTBProblem:problem withFloat:width withFloat:minHeight withInt:towerColor] withBOOL:NO])) {
    targetAlpha_ = 1;
    self.problem_ = problem;
    self.minHeight = minHeight;
    self.towerColor = towerColor;
  }
  return self;
}

+ (id<PlaynCoreImage>)createImageWithTBProblem:(TBProblem *)problem
                                     withFloat:(float)width
                                     withFloat:(float)minHeight
                                       withInt:(int)towerColor {
  float strokeWidth = 5;
  float padding = strokeWidth * 2;
  float rectRad = strokeWidth * 1.5f;
  float eqTextSize = (minHeight - padding * 2) * 0.25f;
  PlaynCoreTextFormat *textFormat = [((PlaynCoreTextFormat *) [[[PlaynCoreTextFormat alloc] init] autorelease]) withFontWithPlaynCoreFont:[((id<PlaynCoreGraphics>) [TBPlayNObject graphics]) createFontWithNSString:[TBConstant FONT_NAME] withPlaynCoreFont_StyleEnum:[PlaynCoreFont_StyleEnum PLAIN] withFloat:eqTextSize]];
  TBExpressionWriter *leftEW = [[[((TBProblem *) NIL_CHK(problem)) equation] leftHandSide] getExpressionWriterWithPlaynCoreTextFormat:textFormat];
  TBExpressionWriter *rightEW = [[[((TBProblem *) NIL_CHK(problem)) equation] rightHandSide] getExpressionWriterWithPlaynCoreTextFormat:textFormat];
  id<PlaynCoreTextLayout> eqLayout = [((id<PlaynCoreGraphics>) [PlaynCorePlayN graphics]) layoutTextWithNSString:@"=" withPlaynCoreTextFormat:textFormat];
  float eqWidth = [((TBExpressionWriter *) NIL_CHK(leftEW)) width] + [((id<PlaynCoreTextLayout>) NIL_CHK(eqLayout)) width] + [((TBExpressionWriter *) NIL_CHK(rightEW)) width] + TBExpressionWriter_SPACING * 2;
  float eqHeight = [JavaLangMath maxWithFloat:[((TBExpressionWriter *) NIL_CHK(leftEW)) height] withFloat:[((TBExpressionWriter *) NIL_CHK(rightEW)) height]];
  float height = [JavaLangMath maxWithFloat:eqHeight + padding * 2 withFloat:minHeight];
  id<PlaynCoreCanvasImage> image = [((id<PlaynCoreGraphics>) [TBPlayNObject graphics]) createImageWithFloat:width withFloat:height];
  id<PlaynCoreCanvas> canvas = [((id<PlaynCoreCanvasImage>) NIL_CHK(image)) canvas];
  float rewardImageSize = minHeight - padding * 2;
  float cellSize = rewardImageSize / 3;
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) setFillColorWithInt:[TripleplayUtilColors WHITE]];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) setStrokeColorWithInt:[TripleplayUtilColors DARK_GRAY]];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) setStrokeWidthWithFloat:strokeWidth];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) fillRoundRectWithFloat:strokeWidth / 2 withFloat:strokeWidth / 2 withFloat:width - strokeWidth withFloat:height - strokeWidth withFloat:rectRad];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) strokeRoundRectWithFloat:strokeWidth / 2 withFloat:strokeWidth / 2 withFloat:width - strokeWidth withFloat:height - strokeWidth withFloat:rectRad];
  TBTowerTypeEnum *reward = [((TBProblem *) NIL_CHK(problem)) reward].tower;
  id<PlaynCoreImage> rewardImage = [[((TBTowerTypeEnum *) NIL_CHK(reward)) instance] createImageWithFloat:cellSize withInt:towerColor];
  float rewardImageX = width - padding - (rewardImageSize + [((id<PlaynCoreImage>) NIL_CHK(rewardImage)) width]) / 2;
  float rewardImageY = padding + (rewardImageSize - [((id<PlaynCoreImage>) NIL_CHK(rewardImage)) height]) / 2;
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) drawImageWithPlaynCoreImage:rewardImage withFloat:rewardImageX withFloat:rewardImageY];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) setFillColorWithInt:[TripleplayUtilColors BLACK]];
  PlaynCoreTextFormat *countFormat = [((PlaynCoreTextFormat *) [[[PlaynCoreTextFormat alloc] init] autorelease]) withFontWithPlaynCoreFont:[((id<PlaynCoreGraphics>) [TBPlayNObject graphics]) createFontWithNSString:[TBConstant FONT_NAME] withPlaynCoreFont_StyleEnum:[PlaynCoreFont_StyleEnum PLAIN] withFloat:rewardImageSize / 5]];
  id<PlaynCoreTextLayout> countLayout = [((id<PlaynCoreGraphics>) [TBPlayNObject graphics]) layoutTextWithNSString:[NSString stringWithFormat:@"x%d", [((TBProblem *) NIL_CHK(problem)) reward].count] withPlaynCoreTextFormat:countFormat];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) fillTextWithPlaynCoreTextLayout:countLayout withFloat:width - padding - rewardImageSize withFloat:padding];
  float lineX = width - padding * 2 - rewardImageSize;
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) drawLineWithFloat:lineX withFloat:0 withFloat:lineX withFloat:height];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) setStrokeWidthWithFloat:1];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) setFillColorWithInt:[TripleplayUtilColors BLACK]];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) setStrokeColorWithInt:[TripleplayUtilColors BLACK]];
  float eqStartX = (lineX - eqWidth) / 2;
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) save];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) translateWithFloat:eqStartX withFloat:(height - [((TBExpressionWriter *) NIL_CHK(leftEW)) height]) / 2];
  [((TBExpressionWriter *) NIL_CHK(leftEW)) drawExpressionWithPlaynCoreCanvas:canvas withInt:[TripleplayUtilColors BLACK]];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) restore];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) save];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) translateWithFloat:eqStartX + [((TBExpressionWriter *) NIL_CHK(leftEW)) width] + TBExpressionWriter_SPACING withFloat:(height - [((id<PlaynCoreTextLayout>) NIL_CHK(eqLayout)) height]) / 2];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) fillTextWithPlaynCoreTextLayout:eqLayout withFloat:0 withFloat:0];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) restore];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) save];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) translateWithFloat:eqStartX + [((id<PlaynCoreTextLayout>) NIL_CHK(eqLayout)) width] + [((TBExpressionWriter *) NIL_CHK(leftEW)) width] + TBExpressionWriter_SPACING * 2 withFloat:(height - [((TBExpressionWriter *) NIL_CHK(rightEW)) height]) / 2];
  [((TBExpressionWriter *) NIL_CHK(rightEW)) drawExpressionWithPlaynCoreCanvas:canvas withInt:[TripleplayUtilColors BLACK]];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) restore];
  return image;
}

- (void)fadeInWithFloat:(float)targetAlpha {
  (void) [((id<PlaynCoreLayer>) [self layerAddable]) setAlphaWithFloat:0];
  self.targetAlpha = targetAlpha;
}

- (void)fadeOut {
  self.targetAlpha = 0;
}

- (void)paintWithPlaynCoreUtilClock:(id<PlaynCoreUtilClock>)clock {
  id<PlaynCoreLayer> layer = [self layerAddable];
  if ([((id<PlaynCoreLayer>) NIL_CHK(layer)) alpha] != targetAlpha_) {
    (void) [((id<PlaynCoreLayer>) NIL_CHK(layer)) setAlphaWithFloat:[TBPlayNObject lerpTimeWithFloat:[((id<PlaynCoreLayer>) NIL_CHK(layer)) alpha] withFloat:targetAlpha_ withFloat:0.99f withFloat:[((id<PlaynCoreUtilClock>) NIL_CHK(clock)) dt]]];
    if ([JavaLangMath absWithFloat:[((id<PlaynCoreLayer>) NIL_CHK(layer)) alpha] - targetAlpha_] < 0.01) (void) [((id<PlaynCoreLayer>) NIL_CHK(layer)) setAlphaWithFloat:targetAlpha_];
  }
  float desiredY = above__ == nil ? 0 : [((TBProblemButton *) NIL_CHK(above__)) bottom];
  desiredY += TBProblemButton_MARGIN + [self height] / 2;
  float y = [TBPlayNObject lerpTimeWithFloat:[self y] withFloat:desiredY withFloat:0.99f withFloat:[((id<PlaynCoreUtilClock>) NIL_CHK(clock)) dt]];
  [self setPositionWithFloat:[self x] withFloat:y];
}

- (void)dealloc {
  JreOperatorRetainedAssign(&below__, self, nil);
  JreOperatorRetainedAssign(&above__, self, nil);
  JreOperatorRetainedAssign(&problem__, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  TBProblemButton *typedCopy = (TBProblemButton *) copy;
  typedCopy.problem_ = problem__;
  typedCopy.minHeight = minHeight_;
  typedCopy.above_ = above__;
  typedCopy.below_ = below__;
  typedCopy.towerColor = towerColor_;
  typedCopy.targetAlpha = targetAlpha_;
}

@end
