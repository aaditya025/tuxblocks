//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: react/AbstractSignal.java
//
//  Created by Thomas on 7/1/13.
//

#import "java/lang/Throwable.h"
#import "react/Connection.h"
#import "react/Cons.h"
#import "react/Function.h"
#import "react/MultiFailureException.h"
#import "react/Reactor.h"
#import "react/SignalView.h"
#import "react/Slot.h"

@implementation ReactAbstractSignal

- (id<ReactSignalView>)mapWithReactFunction:(id<ReactFunction>)func {
  ReactAbstractSignal *outer = self;
  return [[[ReactAbstractSignal_$1 alloc] initWithReactAbstractSignal:outer withReactFunction:func] autorelease];
}

- (id<ReactConnection>)connectWithReactSlot:(ReactSlot *)slot {
  ReactSlot *casted = (ReactSlot *) slot;
  return ((ReactCons *) [self addConnectionWithId:casted]);
}

- (void)disconnectWithReactSlot:(ReactSlot *)slot {
  ReactSlot *casted = (ReactSlot *) slot;
  [self removeConnectionWithId:casted];
}

- (void)notifyEmitWithId:(id)event {
  ReactCons *lners = ((ReactCons *) [self prepareNotify]);
  ReactMultiFailureException *error = nil;
  @try {
    for (ReactCons * cons = lners; cons != nil; cons = ((ReactCons *) NIL_CHK(cons)).next) {
      @try {
        [((ReactSlot *) NIL_CHK(cons.listener)) onEmitWithId:event];
      }
      @catch (JavaLangThrowable *t) {
        if (error == nil) error = [[[ReactMultiFailureException alloc] init] autorelease];
        [((ReactMultiFailureException *) NIL_CHK(error)) addFailureWithJavaLangThrowable:t];
      }
      if (((ReactCons *) NIL_CHK(cons)).oneShot) [((ReactCons *) NIL_CHK(cons)) disconnect];
    }
  }
  @finally {
    [self finishNotifyWithReactCons:lners];
  }
  if (error != nil) [error trigger];
}

- (id)init {
  return [super init];
}

- (void)dealloc {
  [super dealloc];
}

@end
@implementation ReactAbstractSignal_$1

- (ReactAbstractSignal *)val$outer {
  return val$outer_;
}
- (void)setVal$outer:(ReactAbstractSignal *)val$outer {
  JreOperatorRetainedAssign(&val$outer_, self, val$outer);
}
@synthesize val$outer = val$outer_;
- (id<ReactFunction>)val$func {
  return val$func_;
}
- (void)setVal$func:(id<ReactFunction>)val$func {
  JreOperatorRetainedAssign(&val$func_, self, val$func);
}
@synthesize val$func = val$func_;

- (id<ReactConnection>)connect {
  return [((ReactAbstractSignal *) NIL_CHK(val$outer_)) connectWithReactSlot:[[[ReactAbstractSignal_$1_$1 alloc] initWithReactAbstractSignal_$1:self] autorelease]];
}

- (id)initWithReactAbstractSignal:(ReactAbstractSignal *)capture$0
                withReactFunction:(id<ReactFunction>)capture$1 {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&val$outer_, self, capture$0);
    JreOperatorRetainedAssign(&val$func_, self, capture$1);
  }
  return self;
}

- (void)dealloc {
  JreOperatorRetainedAssign(&val$func_, self, nil);
  JreOperatorRetainedAssign(&val$outer_, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  ReactAbstractSignal_$1 *typedCopy = (ReactAbstractSignal_$1 *) copy;
  typedCopy.val$outer = val$outer_;
  typedCopy.val$func = val$func_;
}

@end
@implementation ReactAbstractSignal_$1_$1

- (ReactAbstractSignal_$1 *)this$0 {
  return this$0_;
}
- (void)setThis$0:(ReactAbstractSignal_$1 *)this$0 {
  JreOperatorRetainedAssign(&this$0_, self, this$0);
}
@synthesize this$0 = this$0_;

- (void)onEmitWithId:(id)value {
  [this$0_ notifyEmitWithId:[((id<ReactFunction>) NIL_CHK(this$0_.val$func)) applyWithId:value]];
}

- (id)initWithReactAbstractSignal_$1:(ReactAbstractSignal_$1 *)outer$ {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&this$0_, self, outer$);
  }
  return self;
}

- (void)dealloc {
  JreOperatorRetainedAssign(&this$0_, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  ReactAbstractSignal_$1_$1 *typedCopy = (ReactAbstractSignal_$1_$1 *) copy;
  typedCopy.this$0 = this$0_;
}

@end
