//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: tripleplay/game/trans/PageTurnTransition.java
//
//  Created by Thomas on 7/1/13.
//

#import "IOSClass.h"
#import "playn/core/Graphics.h"
#import "playn/core/GroupLayer.h"
#import "playn/core/ImmediateLayer.h"
#import "playn/core/Layer.h"
#import "playn/core/PlayN.h"
#import "playn/core/Surface.h"
#import "playn/core/gl/GLContext.h"
#import "pythagoras/f/FloatMath.h"
#import "pythagoras/f/MathUtil.h"
#import "tripleplay/game/Screen.h"
#import "tripleplay/shaders/RotateYShader.h"
#import "tripleplay/util/Interpolator.h"

@implementation TripleplayGameTransPageTurnTransition

@synthesize _alpha = _alpha_;
@synthesize _close = _close_;
- (TripleplayGameScreen *)_toflip {
  return _toflip_;
}
- (void)set_toflip:(TripleplayGameScreen *)_toflip {
  JreOperatorRetainedAssign(&_toflip_, self, _toflip);
}
@synthesize _toflip = _toflip_;
- (id<PlaynCoreImmediateLayer>)_shadow {
  return _shadow_;
}
- (void)set_shadow:(id<PlaynCoreImmediateLayer>)_shadow {
  JreOperatorRetainedAssign(&_shadow_, self, _shadow);
}
@synthesize _shadow = _shadow_;
- (TripleplayShadersRotateYShader *)_shader {
  return _shader_;
}
- (void)set_shader:(TripleplayShadersRotateYShader *)_shader {
  JreOperatorRetainedAssign(&_shader_, self, _shader);
}
@synthesize _shader = _shader_;

- (TripleplayGameTransPageTurnTransition *)close {
  _close_ = YES;
  JreOperatorRetainedAssign(&_interp_, self, [TripleplayUtilInterpolator EASE_INOUT]);
  return self;
}

- (void)init__WithTripleplayGameScreen:(TripleplayGameScreen *)oscreen
              withTripleplayGameScreen:(TripleplayGameScreen *)nscreen OBJC_METHOD_FAMILY_NONE {
  [super init__WithTripleplayGameScreen:oscreen withTripleplayGameScreen:nscreen];
  (void) [((id<PlaynCoreGroupLayer>) NIL_CHK(nscreen.layer)) setDepthWithFloat:_close_ ? 1 : -1];
  JreOperatorRetainedAssign(&_toflip_, self, _close_ ? nscreen : oscreen);
  JreOperatorRetainedAssign(&_shader_, self, [[[TripleplayShadersRotateYShader alloc] initWithPlaynCoreGlGLContext:[((id<PlaynCoreGraphics>) [PlaynCorePlayN graphics]) ctx] withFloat:0.0f withFloat:0.5f withFloat:1.5f] autorelease]);
  (void) [((id<PlaynCoreGroupLayer>) NIL_CHK(_toflip_.layer)) setShaderWithPlaynCoreGlGLShader:_shader_];
  float fwidth = [((TripleplayGameScreen *) NIL_CHK(_toflip_)) width], fheight = [((TripleplayGameScreen *) NIL_CHK(_toflip_)) height];
  JreOperatorRetainedAssign(&_shadow_, self, [((id<PlaynCoreGraphics>) [PlaynCorePlayN graphics]) createImmediateLayerWithPlaynCoreImmediateLayer_Renderer:[[[TripleplayGameTransPageTurnTransition_$1 alloc] initWithTripleplayGameTransPageTurnTransition:self withFloat:fwidth withFloat:fheight] autorelease]]);
  [((id<PlaynCoreGroupLayer>) NIL_CHK(_toflip_.layer)) addAtWithPlaynCoreLayer:_shadow_ withFloat:fwidth withFloat:0];
  [self updateAngleWithFloat:0];
}

- (BOOL)updateWithTripleplayGameScreen:(TripleplayGameScreen *)oscreen
              withTripleplayGameScreen:(TripleplayGameScreen *)nscreen
                             withFloat:(float)elapsed {
  [self updateAngleWithFloat:elapsed];
  return elapsed >= _duration_;
}

- (void)completeWithTripleplayGameScreen:(TripleplayGameScreen *)oscreen
                withTripleplayGameScreen:(TripleplayGameScreen *)nscreen {
  [super completeWithTripleplayGameScreen:oscreen withTripleplayGameScreen:nscreen];
  [((id<PlaynCoreImmediateLayer>) NIL_CHK(_shadow_)) destroy];
  (void) [((id<PlaynCoreGroupLayer>) NIL_CHK(nscreen.layer)) setDepthWithFloat:0];
  (void) [((id<PlaynCoreGroupLayer>) NIL_CHK(_toflip_.layer)) setShaderWithPlaynCoreGlGLShader:nil];
}

- (float)defaultDuration {
  return 1500;
}

- (TripleplayUtilInterpolator *)defaultInterpolator {
  return [TripleplayUtilInterpolator EASE_IN];
}

- (void)updateAngleWithFloat:(float)elapsed {
  float pct = [PythagorasFMathUtil clampWithFloat:[((TripleplayUtilInterpolator *) NIL_CHK(_interp_)) applyWithFloat:0 withFloat:0.5f withFloat:elapsed withFloat:_duration_] withFloat:0 withFloat:0.5f];
  if (_close_) pct = 0.5f - pct;
  _alpha_ = pct;
  ((TripleplayShadersRotateYShader *) NIL_CHK(_shader_)).angle = PythagorasFFloatMath_PI * pct;
}

- (id)init {
  return [super init];
}

- (void)dealloc {
  JreOperatorRetainedAssign(&_shader_, self, nil);
  JreOperatorRetainedAssign(&_shadow_, self, nil);
  JreOperatorRetainedAssign(&_toflip_, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  TripleplayGameTransPageTurnTransition *typedCopy = (TripleplayGameTransPageTurnTransition *) copy;
  typedCopy._alpha = _alpha_;
  typedCopy._close = _close_;
  typedCopy._toflip = _toflip_;
  typedCopy._shadow = _shadow_;
  typedCopy._shader = _shader_;
}

@end
@implementation TripleplayGameTransPageTurnTransition_$1

- (TripleplayGameTransPageTurnTransition *)this$0 {
  return this$0_;
}
- (void)setThis$0:(TripleplayGameTransPageTurnTransition *)this$0 {
  JreOperatorRetainedAssign(&this$0_, self, this$0);
}
@synthesize this$0 = this$0_;
@synthesize val$fwidth = val$fwidth_;
@synthesize val$fheight = val$fheight_;

- (void)renderWithPlaynCoreSurface:(id<PlaynCoreSurface>)surf {
  (void) [((id<PlaynCoreSurface>) NIL_CHK(surf)) setAlphaWithFloat:this$0_._alpha];
  (void) [((id<PlaynCoreSurface>) NIL_CHK(surf)) setFillColorWithInt:(int) 0xFF000000];
  (void) [((id<PlaynCoreSurface>) NIL_CHK(surf)) fillRectWithFloat:0 withFloat:0 withFloat:val$fwidth_ / 4 withFloat:val$fheight_];
}

- (id)initWithTripleplayGameTransPageTurnTransition:(TripleplayGameTransPageTurnTransition *)outer$
                                          withFloat:(float)capture$0
                                          withFloat:(float)capture$1 {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&this$0_, self, outer$);
    val$fwidth_ = capture$0;
    val$fheight_ = capture$1;
  }
  return self;
}

- (void)dealloc {
  JreOperatorRetainedAssign(&this$0_, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  TripleplayGameTransPageTurnTransition_$1 *typedCopy = (TripleplayGameTransPageTurnTransition_$1 *) copy;
  typedCopy.this$0 = this$0_;
  typedCopy.val$fwidth = val$fwidth_;
  typedCopy.val$fheight = val$fheight_;
}

@end
